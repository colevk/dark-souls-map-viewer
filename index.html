<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Dark Souls Map Viewer</title>
  <link href="css/reset.css" rel="stylesheet" type="text/css">
  <link href="css/foundation.min.css" rel="stylesheet" type="text/css">
  <style>
  input {
    margin-bottom: 0.2rem !important;
  }
  button {
    margin-bottom: 0rem !important;
  }
  input.pos {
    display: inline;
    width: 2rem;
    margin-bottom: 0.5rem !important;
  }
  label {
    display: inline;
  }
  </style>

  <script src="js/lib/jquery-2.1.1.min.js"></script>
  <script src="js/lib/three.min.js"></script>

  <script src="js/BigShader.js"></script>
  <script src="js/Interface.js"></script>
  <script src="js/Controls.js"></script>
  <script src="js/SceneLoader.js"></script>
  <script src="js/Config.js"></script>
</head>

<body style="overflow:hidden;">
  <div id="sidebar" class="panel" style="height: 100vh; width: 25rem; float: right; overflow: auto">
    <h4>Dark Souls Map Viewer</h4>
    <hr>
    <label>
      W, A, S, D, R, F &mdash; Move<br>
      Shift &mdash; Speed up<br>
      Mouse &mdash; Look<br>
    </label>
    <hr>
    <label><input id="normalShading" type="checkbox" onchange="iface.toggleNormalShading()"> Show normals</label><br>
    <label><input id="edgeHighlight" type="checkbox" onchange="iface.toggleEdgeHighlighting()"> Highlight edges</label><br>
    <label><input id="edgeAttenuation" type="checkbox" onchange="iface.toggleEdgeAttenuation()"> Attenuate edge highlighting with distance</label><br>
    <label><input id="backfaceCulling" type="checkbox" onchange="iface.toggleBackfaceCulling()"> Cull backfaces</label><br>
    <label><input id="wrapAround" type="checkbox" onchange="iface.toggleWrapAround()"> Wrap-around lighting</label><br>

    <label><input type="color" value="#000000" onchange="iface.setEdgeColor(this.value)"> Edge color</label><br>
    <label><input type="color" value="#ffffff" onchange="iface.setLightColor(this.value)"> Light color</label><br>

    <label>x: <input id="light-x" class="pos" onchange="iface.setLightPos(this.value, null, null)"></label>
    <label>y: <input id="light-y" class="pos" onchange="iface.setLightPos(null, this.value, null)"></label>
    <label>z: <input id="light-z" class="pos" onchange="iface.setLightPos(null, null, this.value)"></label>
    <label>Light direction</label><br>

    <button class="button tiny" onclick="iface.resetCamera()">Reset camera position</button>
    <hr>
    <select onchange="iface.swapGames(this.value)">
      <option value="ds1">Dark Souls 1</option>
      <option value="ds2">Dark Souls 2</option>
    </select><br>
    <div id="ds1" class="file-list"></div>
    <div id="ds2" class="file-list"></div>
  </div>
  <div id="canvas" style="height: 100%; margin-right: 25rem;"></div>

  <script>
  var sidebar, canvas, renderer, clock, scene, camera, controls, material,
      meshes, light, iface;

  /**
   * Create and set all global variables and controls
   */
  function init() {
    sidebar = $('#sidebar');
    canvas = $('#canvas');

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(canvas.width(), canvas.height());
    canvas.append(renderer.domElement);

    clock = new THREE.Clock();
    scene = new THREE.Scene();
    material = BigShaderMaterial;

    camera = new THREE.PerspectiveCamera( 75, canvas.width() / canvas.height(), 0.1, 10000 );

    // Reset aspect ratio when window is resized
    $(window).resize(function() {
      renderer.setSize(canvas.width(), canvas.height());
      camera.aspect = canvas.width() / canvas.height();
      camera.updateProjectionMatrix();
    })

    var havePointerLock = 'pointerLockElement' in document ||
                          'mozPointerLockElement' in document ||
                          'webkitPointerLockElement' in document;

    // Only use pointer lock controls if browser supports them
    if (havePointerLock) {
      controls = new PointerLockControls(camera, renderer.domElement);

      var element = canvas.get()[0];

      // Enable controls only when pointer is locked.
			var pointerlockchange = function() {
				if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
					controls.enabled = true;
				} else {
					controls.enabled = false;
				}
			}

			// Hook pointer lock state change events
			document.addEventListener('pointerlockchange', pointerlockchange, false);
			document.addEventListener('mozpointerlockchange', pointerlockchange, false);
			document.addEventListener('webkitpointerlockchange', pointerlockchange, false);

			canvas.click(function() {
				element.requestPointerLock = element.requestPointerLock ||
                                     element.mozRequestPointerLock ||
                                     element.webkitRequestPointerLock;
				element.requestPointerLock();
			});
    } else {
      // Use backup controls
      controls = new NoPointerLockControls(camera, renderer.domElement);
    }

    camera.position = Config.defaultCameraPosition();
    camera.lookAt(Config.defaultCameraLookAt());

    meshes = [];

    // Load Dark Souls 1 files into meshes, annotated with the game and file
    // that they are associated with.
    for (var i = 0, lenI = Config.ds1.length; i < lenI; i++) {
      (function(fileNumber) { // pass loop variable into scope
        function loadFunc(bufferGeometry) {
          var mesh = new THREE.Mesh(bufferGeometry, BigShaderMaterial);
          mesh.game = 'ds1';
          mesh.fileNumber = fileNumber;
          meshes.push(mesh);

          // Make default files visible.
          if (Config.ds1State[fileNumber]) { scene.add(mesh); }
        };

        SceneLoader.loadIVFile('data/ds1/' + Config.ds1[i] + '.iv', loadFunc);
      })(i);
    }

    // Load Dark Souls 2 files into meshes, annotated with the game and file
    // that they are associated with.
    for (var i = 0, lenI = Config.ds2.length; i < lenI; i++) {
      (function(fileNumber) { // pass loop variable into scope
        function loadFunc(bufferGeometry) {
          var mesh = new THREE.Mesh(bufferGeometry, BigShaderMaterial);
          mesh.game = 'ds2';
          mesh.fileNumber = fileNumber;
          meshes.push(mesh);
        };

        SceneLoader.loadIVFile('data/ds2/' + Config.ds2[i] + '.iv', loadFunc);
      })(i);
    }

    light = Config.light;
    scene.add(light);
  }

  /**
   * Render the scene and update controls.
   */
  function render() {
    requestAnimationFrame(render);

    controls.update(clock.getDelta());
    renderer.render(scene, camera);
  };

  /**
   * Determine if browser supports WebGL.
   */
  function hasWebGL() {
    try {
      var canvas = document.createElement('canvas');
      return !! window.WebGLRenderingContext &&
        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
    } catch(e) {
      return false;
    }
  }

  if (hasWebGL()) {
    // Run the program.
    init();
    iface = new Interface(scene, camera, meshes, material, light, Config);
    iface.setupInterface();
    render();
  } else {
    // Provide error message
    var element = document.createElement( 'div' );
    element.style.textAlign = 'center';
    element.style.padding = '1.5em';
    element.style['padding-top'] = '6.5em';
    element.style.width = '450px';
    element.style.margin = 'auto';

    element.innerHTML = window.WebGLRenderingContext ?
      'Your graphics card does not seem to support WebGL.' :
      'Your browser does not seem to support WebGL';

    canvas.appendChild(element);
  }
  </script>
</body>
</html>
